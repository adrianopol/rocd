// Code generated by goderive DO NOT EDIT.

package models

import (
	"sort"
	"strings"
)

// deriveCompareAddress returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareAddress(this, that *Address) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if c := strings.Compare(string(this.AudioSource), string(that.AudioSource)); c != 0 {
		return c
	}
	if c := strings.Compare(string(this.AudioRepair), string(that.AudioRepair)); c != 0 {
		return c
	}
	if c := strings.Compare(string(this.AudioControl), string(that.AudioControl)); c != 0 {
		return c
	}
	return 0
}

// deriveCompareAddressList returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareAddressList(this, that *AddressList) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	return deriveCompare(*this, *that)
}

// deriveCompareDevice returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareDevice(this, that *Device) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if c := strings.Compare(this.UID, that.UID); c != 0 {
		return c
	}
	if c := strings.Compare(this.SystemName, that.SystemName); c != 0 {
		return c
	}
	if c := strings.Compare(this.DisplayName, that.DisplayName); c != 0 {
		return c
	}
	if c := strings.Compare(string(this.Type), string(that.Type)); c != 0 {
		return c
	}
	if c := strings.Compare(string(this.Driver), string(that.Driver)); c != 0 {
		return c
	}
	if c := deriveCompare_(this.IsHardware, that.IsHardware); c != 0 {
		return c
	}
	if c := deriveCompare_(this.IsStream, that.IsStream); c != 0 {
		return c
	}
	if c := strings.Compare(string(this.Status), string(that.Status)); c != 0 {
		return c
	}
	if c := deriveCompare_1(this.IsMuted, that.IsMuted); c != 0 {
		return c
	}
	if c := this.ToAddress.Compare(that.ToAddress); c != 0 {
		return c
	}
	if c := this.FromAddress.Compare(that.FromAddress); c != 0 {
		return c
	}
	if c := strings.Compare(this.NodeID, that.NodeID); c != 0 {
		return c
	}
	if c := strings.Compare(this.ModuleID, that.ModuleID); c != 0 {
		return c
	}
	return 0
}

// deriveCompareDeviceMap returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareDeviceMap(this, that *DeviceMap) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	return deriveCompare_D(*this, *that)
}

// deriveCompareEvent returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareEvent(this, that *Event) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if c := strings.Compare(string(this.Type), string(that.Type)); c != 0 {
		return c
	}
	if c := strings.Compare(this.DeviceUID, that.DeviceUID); c != 0 {
		return c
	}
	return 0
}

// deriveCompareStream returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareStream(this, that *Stream) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if c := strings.Compare(this.UID, that.UID); c != 0 {
		return c
	}
	if c := strings.Compare(string(this.Type), string(that.Type)); c != 0 {
		return c
	}
	if c := strings.Compare(this.FromDevice, that.FromDevice); c != 0 {
		return c
	}
	if c := this.ToAddress.Compare(&that.ToAddress); c != 0 {
		return c
	}
	if c := strings.Compare(this.ToDevice, that.ToDevice); c != 0 {
		return c
	}
	if c := this.FromAddress.Compare(&that.FromAddress); c != 0 {
		return c
	}
	return 0
}

// deriveCompareStreamMap returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompareStreamMap(this, that *StreamMap) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	return deriveCompare_S(*this, *that)
}

// deriveEqualAddress returns whether this and that are equal.
func deriveEqualAddress(this, that *Address) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.AudioSource == that.AudioSource &&
			this.AudioRepair == that.AudioRepair &&
			this.AudioControl == that.AudioControl
}

// deriveEqualAddressList returns whether this and that are equal.
func deriveEqualAddressList(this, that *AddressList) bool {
	if this == nil && that == nil {
		return true
	}
	if this != nil && that != nil {
		if *this == nil || *that == nil {
			return *this == nil && *that == nil
		}
		if len(*this) != len(*that) {
			return false
		}
		for i := 0; i < len(*this); i++ {
			if !(*this)[i].Equal(&(*that)[i]) {
				return false
			}
		}
		return true
	}
	return false
}

// deriveEqualDevice returns whether this and that are equal.
func deriveEqualDevice(this, that *Device) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.UID == that.UID &&
			this.SystemName == that.SystemName &&
			this.DisplayName == that.DisplayName &&
			this.Type == that.Type &&
			this.Driver == that.Driver &&
			this.IsHardware == that.IsHardware &&
			this.IsStream == that.IsStream &&
			this.Status == that.Status &&
			((this.IsMuted == nil && that.IsMuted == nil) || (this.IsMuted != nil && that.IsMuted != nil && *(this.IsMuted) == *(that.IsMuted))) &&
			this.ToAddress.Equal(that.ToAddress) &&
			this.FromAddress.Equal(that.FromAddress) &&
			this.NodeID == that.NodeID &&
			this.ModuleID == that.ModuleID
}

// deriveEqualDeviceMap returns whether this and that are equal.
func deriveEqualDeviceMap(this, that *DeviceMap) bool {
	if this == nil && that == nil {
		return true
	}
	if this != nil && that != nil {
		if *this == nil || *that == nil {
			return *this == nil && *that == nil
		}
		if len(*this) != len(*that) {
			return false
		}
		for k, v := range *this {
			thatv, ok := (*that)[k]
			if !ok {
				return false
			}
			if !(v.Equal(thatv)) {
				return false
			}
		}
		return true
	}
	return false
}

// deriveEqualEvent returns whether this and that are equal.
func deriveEqualEvent(this, that *Event) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.Type == that.Type &&
			this.DeviceUID == that.DeviceUID
}

// deriveEqualStream returns whether this and that are equal.
func deriveEqualStream(this, that *Stream) bool {
	return (this == nil && that == nil) ||
		this != nil && that != nil &&
			this.UID == that.UID &&
			this.Type == that.Type &&
			this.FromDevice == that.FromDevice &&
			this.ToAddress.Equal(&that.ToAddress) &&
			this.ToDevice == that.ToDevice &&
			this.FromAddress.Equal(&that.FromAddress)
}

// deriveEqualStreamMap returns whether this and that are equal.
func deriveEqualStreamMap(this, that *StreamMap) bool {
	if this == nil && that == nil {
		return true
	}
	if this != nil && that != nil {
		if *this == nil || *that == nil {
			return *this == nil && *that == nil
		}
		if len(*this) != len(*that) {
			return false
		}
		for k, v := range *this {
			thatv, ok := (*that)[k]
			if !ok {
				return false
			}
			if !(v.Equal(thatv)) {
				return false
			}
		}
		return true
	}
	return false
}

// deriveCloneAddress returns a clone of the src parameter.
func deriveCloneAddress(src *Address) *Address {
	if src == nil {
		return nil
	}
	dst := new(Address)
	deriveDeepCopy(dst, src)
	return dst
}

// deriveCloneAddressList returns a clone of the src parameter.
func deriveCloneAddressList(src *AddressList) *AddressList {
	if src == nil {
		return nil
	}
	dst := new(AddressList)
	deriveDeepCopy_(dst, src)
	return dst
}

// deriveCloneDevice returns a clone of the src parameter.
func deriveCloneDevice(src *Device) *Device {
	if src == nil {
		return nil
	}
	dst := new(Device)
	deriveDeepCopy_1(dst, src)
	return dst
}

// deriveCloneDeviceMap returns a clone of the src parameter.
func deriveCloneDeviceMap(src *DeviceMap) *DeviceMap {
	if src == nil {
		return nil
	}
	dst := new(DeviceMap)
	deriveDeepCopy_2(dst, src)
	return dst
}

// deriveCloneEvent returns a clone of the src parameter.
func deriveCloneEvent(src *Event) *Event {
	if src == nil {
		return nil
	}
	dst := new(Event)
	deriveDeepCopy_3(dst, src)
	return dst
}

// deriveCloneStream returns a clone of the src parameter.
func deriveCloneStream(src *Stream) *Stream {
	if src == nil {
		return nil
	}
	dst := new(Stream)
	deriveDeepCopy_4(dst, src)
	return dst
}

// deriveCloneStreamMap returns a clone of the src parameter.
func deriveCloneStreamMap(src *StreamMap) *StreamMap {
	if src == nil {
		return nil
	}
	dst := new(StreamMap)
	deriveDeepCopy_5(dst, src)
	return dst
}

// deriveHashAddress returns the hash of the object.
func deriveHashAddress(object *Address) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	h = 31*h + deriveHash(object.AudioSource)
	h = 31*h + deriveHash(object.AudioRepair)
	h = 31*h + deriveHash(object.AudioControl)
	return h
}

// deriveHashAddressList returns the hash of the object.
func deriveHashAddressList(object *AddressList) uint64 {
	if object == nil {
		return 0
	}
	return (31 * 17) + deriveHash_(*object)
}

// deriveHashDevice returns the hash of the object.
func deriveHashDevice(object *Device) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	h = 31*h + deriveHash_s(object.UID)
	h = 31*h + deriveHash_s(object.SystemName)
	h = 31*h + deriveHash_s(object.DisplayName)
	h = 31*h + deriveHash_D(object.Type)
	h = 31*h + deriveHash_De(object.Driver)
	h = 31*h + deriveHash_b(object.IsHardware)
	h = 31*h + deriveHash_b(object.IsStream)
	h = 31*h + deriveHash_Dev(object.Status)
	h = 31*h + deriveHash_1(object.IsMuted)
	h = 31*h + deriveHashAddressList(object.ToAddress)
	h = 31*h + deriveHashAddressList(object.FromAddress)
	h = 31*h + deriveHash_s(object.NodeID)
	h = 31*h + deriveHash_s(object.ModuleID)
	return h
}

// deriveHashDeviceMap returns the hash of the object.
func deriveHashDeviceMap(object *DeviceMap) uint64 {
	if object == nil {
		return 0
	}
	return (31 * 17) + deriveHash_Devi(*object)
}

// deriveHashEvent returns the hash of the object.
func deriveHashEvent(object *Event) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	h = 31*h + deriveHash_E(object.Type)
	h = 31*h + deriveHash_s(object.DeviceUID)
	return h
}

// deriveHashStream returns the hash of the object.
func deriveHashStream(object *Stream) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	h = 31*h + deriveHash_s(object.UID)
	h = 31*h + deriveHash_S(object.Type)
	h = 31*h + deriveHash_s(object.FromDevice)
	h = 31*h + deriveHash_(object.ToAddress)
	h = 31*h + deriveHash_s(object.ToDevice)
	h = 31*h + deriveHash_(object.FromAddress)
	return h
}

// deriveHashStreamMap returns the hash of the object.
func deriveHashStreamMap(object *StreamMap) uint64 {
	if object == nil {
		return 0
	}
	return (31 * 17) + deriveHash_St(*object)
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src *Address) {
	dst.AudioSource = src.AudioSource
	dst.AudioRepair = src.AudioRepair
	dst.AudioControl = src.AudioControl
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src *AddressList) {
	if *src == nil {
		*dst = nil
	} else {
		if *dst != nil {
			if len(*src) > len(*dst) {
				if cap(*dst) >= len(*src) {
					*dst = (*dst)[:len(*src)]
				} else {
					*dst = make([]Address, len(*src))
				}
			} else if len(*src) < len(*dst) {
				*dst = (*dst)[:len(*src)]
			}
		} else {
			*dst = make([]Address, len(*src))
		}
		copy(*dst, *src)
	}
}

// deriveDeepCopy_1 recursively copies the contents of src into dst.
func deriveDeepCopy_1(dst, src *Device) {
	dst.UID = src.UID
	dst.SystemName = src.SystemName
	dst.DisplayName = src.DisplayName
	dst.Type = src.Type
	dst.Driver = src.Driver
	dst.IsHardware = src.IsHardware
	dst.IsStream = src.IsStream
	dst.Status = src.Status
	if src.IsMuted == nil {
		dst.IsMuted = nil
	} else {
		dst.IsMuted = new(bool)
		*dst.IsMuted = *src.IsMuted
	}
	if src.ToAddress == nil {
		dst.ToAddress = nil
	} else {
		dst.ToAddress = new(AddressList)
		deriveDeepCopy_(dst.ToAddress, src.ToAddress)
	}
	if src.FromAddress == nil {
		dst.FromAddress = nil
	} else {
		dst.FromAddress = new(AddressList)
		deriveDeepCopy_(dst.FromAddress, src.FromAddress)
	}
	dst.NodeID = src.NodeID
	dst.ModuleID = src.ModuleID
}

// deriveDeepCopy_2 recursively copies the contents of src into dst.
func deriveDeepCopy_2(dst, src *DeviceMap) {
	if *src != nil {
		*dst = make(map[string]*Device, len(*src))
		deriveDeepCopy_6(*dst, *src)
	} else {
		*dst = nil
	}
}

// deriveDeepCopy_3 recursively copies the contents of src into dst.
func deriveDeepCopy_3(dst, src *Event) {
	dst.Type = src.Type
	dst.DeviceUID = src.DeviceUID
}

// deriveDeepCopy_4 recursively copies the contents of src into dst.
func deriveDeepCopy_4(dst, src *Stream) {
	dst.UID = src.UID
	dst.Type = src.Type
	dst.FromDevice = src.FromDevice
	if src.ToAddress == nil {
		dst.ToAddress = nil
	} else {
		if dst.ToAddress != nil {
			if len(src.ToAddress) > len(dst.ToAddress) {
				if cap(dst.ToAddress) >= len(src.ToAddress) {
					dst.ToAddress = (dst.ToAddress)[:len(src.ToAddress)]
				} else {
					dst.ToAddress = make([]Address, len(src.ToAddress))
				}
			} else if len(src.ToAddress) < len(dst.ToAddress) {
				dst.ToAddress = (dst.ToAddress)[:len(src.ToAddress)]
			}
		} else {
			dst.ToAddress = make([]Address, len(src.ToAddress))
		}
		copy(dst.ToAddress, src.ToAddress)
	}
	dst.ToDevice = src.ToDevice
	if src.FromAddress == nil {
		dst.FromAddress = nil
	} else {
		if dst.FromAddress != nil {
			if len(src.FromAddress) > len(dst.FromAddress) {
				if cap(dst.FromAddress) >= len(src.FromAddress) {
					dst.FromAddress = (dst.FromAddress)[:len(src.FromAddress)]
				} else {
					dst.FromAddress = make([]Address, len(src.FromAddress))
				}
			} else if len(src.FromAddress) < len(dst.FromAddress) {
				dst.FromAddress = (dst.FromAddress)[:len(src.FromAddress)]
			}
		} else {
			dst.FromAddress = make([]Address, len(src.FromAddress))
		}
		copy(dst.FromAddress, src.FromAddress)
	}
}

// deriveDeepCopy_5 recursively copies the contents of src into dst.
func deriveDeepCopy_5(dst, src *StreamMap) {
	if *src != nil {
		*dst = make(map[string]*Stream, len(*src))
		deriveDeepCopy_7(*dst, *src)
	} else {
		*dst = nil
	}
}

// deriveCompare returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompare(this, that AddressList) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if len(this) != len(that) {
		if len(this) < len(that) {
			return -1
		}
		return 1
	}
	for i := 0; i < len(this); i++ {
		if c := this[i].Compare(&that[i]); c != 0 {
			return c
		}
	}
	return 0
}

// deriveCompare_ returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompare_(this, that bool) int {
	if this == that {
		return 0
	}
	if that {
		return -1
	}
	return 1
}

// deriveCompare_1 returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompare_1(this, that *bool) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	return deriveCompare_(*this, *that)
}

// deriveCompare_D returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompare_D(this, that DeviceMap) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if len(this) != len(that) {
		if len(this) < len(that) {
			return -1
		}
		return 1
	}
	thiskeys := deriveSort(deriveKeys(this))
	thatkeys := deriveSort(deriveKeys(that))
	for i, thiskey := range thiskeys {
		thatkey := thatkeys[i]
		if thiskey == thatkey {
			thisvalue := this[thiskey]
			thatvalue := that[thatkey]
			if c := thisvalue.Compare(thatvalue); c != 0 {
				return c
			}
		} else {
			if c := strings.Compare(thiskey, thatkey); c != 0 {
				return c
			}
		}
	}
	return 0
}

// deriveCompare_S returns:
//   * 0 if this and that are equal,
//   * -1 is this is smaller and
//   * +1 is this is bigger.
func deriveCompare_S(this, that StreamMap) int {
	if this == nil {
		if that == nil {
			return 0
		}
		return -1
	}
	if that == nil {
		return 1
	}
	if len(this) != len(that) {
		if len(this) < len(that) {
			return -1
		}
		return 1
	}
	thiskeys := deriveSort(deriveKeys_(this))
	thatkeys := deriveSort(deriveKeys_(that))
	for i, thiskey := range thiskeys {
		thatkey := thatkeys[i]
		if thiskey == thatkey {
			thisvalue := this[thiskey]
			thatvalue := that[thatkey]
			if c := thisvalue.Compare(thatvalue); c != 0 {
				return c
			}
		} else {
			if c := strings.Compare(thiskey, thatkey); c != 0 {
				return c
			}
		}
	}
	return 0
}

// deriveSort sorts the slice inplace and also returns it.
func deriveSort(list []string) []string {
	sort.Strings(list)
	return list
}

// deriveKeys returns the keys of the input map as a slice.
func deriveKeys(m map[string]*Device) []string {
	keys := make([]string, 0, len(m))
	for key := range m {
		keys = append(keys, key)
	}
	return keys
}

// deriveKeys_ returns the keys of the input map as a slice.
func deriveKeys_(m map[string]*Stream) []string {
	keys := make([]string, 0, len(m))
	for key := range m {
		keys = append(keys, key)
	}
	return keys
}

// deriveHash returns the hash of the object.
func deriveHash(object URI) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_ returns the hash of the object.
func deriveHash_(object AddressList) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	for i := 0; i < len(object); i++ {
		h = 31*h + deriveHash_A(object[i])
	}
	return h
}

// deriveHash_s returns the hash of the object.
func deriveHash_s(object string) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_D returns the hash of the object.
func deriveHash_D(object DeviceType) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_De returns the hash of the object.
func deriveHash_De(object DeviceDriver) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_b returns the hash of the object.
func deriveHash_b(object bool) uint64 {
	if object {
		return 1
	}
	return 0
}

// deriveHash_Dev returns the hash of the object.
func deriveHash_Dev(object DeviceStatus) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_1 returns the hash of the object.
func deriveHash_1(object *bool) uint64 {
	if object == nil {
		return 0
	}
	return (31 * 17) + deriveHash_b(*object)
}

// deriveHash_Devi returns the hash of the object.
func deriveHash_Devi(object DeviceMap) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	for _, k := range deriveSort(deriveKeys(object)) {
		h = 31*h + deriveHash_s(k)
		h = 31*h + deriveHashDevice(object[k])
	}
	return h
}

// deriveHash_E returns the hash of the object.
func deriveHash_E(object EventType) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_S returns the hash of the object.
func deriveHash_S(object StreamType) uint64 {
	var h uint64
	for _, c := range object {
		h = 31*h + uint64(c)
	}
	return h
}

// deriveHash_St returns the hash of the object.
func deriveHash_St(object StreamMap) uint64 {
	if object == nil {
		return 0
	}
	h := uint64(17)
	for _, k := range deriveSort(deriveKeys_(object)) {
		h = 31*h + deriveHash_s(k)
		h = 31*h + deriveHashStream(object[k])
	}
	return h
}

// deriveDeepCopy_6 recursively copies the contents of src into dst.
func deriveDeepCopy_6(dst, src map[string]*Device) {
	for src_key, src_value := range src {
		if src_value == nil {
			dst[src_key] = nil
		}
		if src_value == nil {
			dst[src_key] = nil
		} else {
			dst[src_key] = new(Device)
			deriveDeepCopy_1(dst[src_key], src_value)
		}
	}
}

// deriveDeepCopy_7 recursively copies the contents of src into dst.
func deriveDeepCopy_7(dst, src map[string]*Stream) {
	for src_key, src_value := range src {
		if src_value == nil {
			dst[src_key] = nil
		}
		if src_value == nil {
			dst[src_key] = nil
		} else {
			dst[src_key] = new(Stream)
			deriveDeepCopy_4(dst[src_key], src_value)
		}
	}
}

// deriveHash_A returns the hash of the object.
func deriveHash_A(object Address) uint64 {
	return deriveHashAddress(&object)
}
